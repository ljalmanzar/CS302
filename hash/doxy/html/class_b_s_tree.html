<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Hash: BSTree&lt; DataType, KeyType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hash
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Implementation of a Hash Table</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_b_s_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BSTree&lt; DataType, KeyType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_b_s_tree_8h_source.html">BSTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4513fc6697f5e51bff8e7c448b446c9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4513fc6697f5e51bff8e7c448b446c9e">BSTree</a> ()</td></tr>
<tr class="separator:a4513fc6697f5e51bff8e7c448b446c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658391c178cb35858c9c465e1839fb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a6658391c178cb35858c9c465e1839fb0">BSTree</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;other)</td></tr>
<tr class="separator:a6658391c178cb35858c9c465e1839fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36b0b564aa3c411c239d730f506f448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree.html">BSTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac36b0b564aa3c411c239d730f506f448">operator=</a> (const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;other)</td></tr>
<tr class="separator:ac36b0b564aa3c411c239d730f506f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968c51c539f4ae41357c78b6a60fea4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a968c51c539f4ae41357c78b6a60fea4c">~BSTree</a> ()</td></tr>
<tr class="separator:a968c51c539f4ae41357c78b6a60fea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86b4cea496ee53076021126423d51fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ab86b4cea496ee53076021126423d51fd">insert</a> (const DataType &amp;newDataItem)</td></tr>
<tr class="separator:ab86b4cea496ee53076021126423d51fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4359bfee390669b5adaf0380ef62b18d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a4359bfee390669b5adaf0380ef62b18d">retrieve</a> (const KeyType &amp;searchKey, DataType &amp;searchDataItem) const </td></tr>
<tr class="separator:a4359bfee390669b5adaf0380ef62b18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755549f7b88d0178a96ca84afd5e04cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a755549f7b88d0178a96ca84afd5e04cf">remove</a> (const KeyType &amp;deleteKey)</td></tr>
<tr class="separator:a755549f7b88d0178a96ca84afd5e04cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f08f48e6d1bbe3eb726856a947325e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a7f08f48e6d1bbe3eb726856a947325e7">writeKeys</a> () const </td></tr>
<tr class="separator:a7f08f48e6d1bbe3eb726856a947325e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926822d08f3d0321603f9fafd2254b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a926822d08f3d0321603f9fafd2254b16">clear</a> ()</td></tr>
<tr class="separator:a926822d08f3d0321603f9fafd2254b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43768375369ca8fe641a86451997ad45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a43768375369ca8fe641a86451997ad45">isEmpty</a> () const </td></tr>
<tr class="separator:a43768375369ca8fe641a86451997ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28277cacbf8ab33326473a419abf097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac28277cacbf8ab33326473a419abf097">showStructure</a> () const </td></tr>
<tr class="separator:ac28277cacbf8ab33326473a419abf097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3850adc6b8ae965ec11ec0e0567b6f7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a3850adc6b8ae965ec11ec0e0567b6f7d">getHeight</a> () const </td></tr>
<tr class="separator:a3850adc6b8ae965ec11ec0e0567b6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d98553153533d3c29504e8a272c7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a880d98553153533d3c29504e8a272c7d">getCount</a> () const </td></tr>
<tr class="separator:a880d98553153533d3c29504e8a272c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92079e5301185f41eebe1c32c2357258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a92079e5301185f41eebe1c32c2357258">writeLessThan</a> (const KeyType &amp;searchKey) const </td></tr>
<tr class="separator:a92079e5301185f41eebe1c32c2357258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a44b3002e3476eb410468a4b9aaaa73ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a44b3002e3476eb410468a4b9aaaa73ef">showHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *p, int level) const </td></tr>
<tr class="separator:a44b3002e3476eb410468a4b9aaaa73ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f54ec6e60536aafa6e3130968e4858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#ac0f54ec6e60536aafa6e3130968e4858">insertHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;location, const DataType &amp;newDataItem)</td></tr>
<tr class="separator:ac0f54ec6e60536aafa6e3130968e4858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2944702e1c5fe498b8fd93a2c28dab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#aae2944702e1c5fe498b8fd93a2c28dab">retrieveHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *location, const KeyType &amp;searchKey, DataType &amp;searchDataItem) const </td></tr>
<tr class="separator:aae2944702e1c5fe498b8fd93a2c28dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11efb310116399fde0c83c6991a37f7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a11efb310116399fde0c83c6991a37f7d">removeHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;location, const KeyType &amp;deleteKey)</td></tr>
<tr class="separator:a11efb310116399fde0c83c6991a37f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36adcef767ab5a35a9de275aef841d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a36adcef767ab5a35a9de275aef841d9c">writeKeysHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *location) const </td></tr>
<tr class="separator:a36adcef767ab5a35a9de275aef841d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686803ea42d32427487652d229353846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a686803ea42d32427487652d229353846">clearHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;location)</td></tr>
<tr class="separator:a686803ea42d32427487652d229353846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fef36c2ff90833730980767afbe3735"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a7fef36c2ff90833730980767afbe3735">heightHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *location) const </td></tr>
<tr class="separator:a7fef36c2ff90833730980767afbe3735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad81734b14dcf5a934965b54391e4f7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#aad81734b14dcf5a934965b54391e4f7a">countHelper</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *location) const </td></tr>
<tr class="separator:aad81734b14dcf5a934965b54391e4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38d3e51bdc88701cc2db1913c3b6065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#aa38d3e51bdc88701cc2db1913c3b6065">copyHelp</a> (<a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;home, <a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *RHS)</td></tr>
<tr class="separator:aa38d3e51bdc88701cc2db1913c3b6065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a83534afce9094181ac031f9f596a8625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_tree.html#a83534afce9094181ac031f9f596a8625">root</a></td></tr>
<tr class="separator:a83534afce9094181ac031f9f596a8625"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4513fc6697f5e51bff8e7c448b446c9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default BST constuctor.</p>
<p>Just initializes a new BST tree by setting its root to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constructor.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>There is a new initialized tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a6658391c178cb35858c9c465e1839fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the copy constructor.</p>
<p>Will create a new BST tree with the data from the parameter. Uses the overloaded assignment operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Another</td><td>BST to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constructor.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There should be one tree already initialized. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>There will be two identical trees. </dd></dl>

</div>
</div>
<a class="anchor" id="a968c51c539f4ae41357c78b6a60fea4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::~<a class="el" href="class_b_s_tree.html">BSTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the tree destructor.</p>
<p>Deallocates all the memory of the tree by calling the clear function (details of that in function) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Destructor.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There should be an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All memory will be deallocated. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a926822d08f3d0321603f9fafd2254b16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that will deallocate all memory of the BST.</p>
<p>Calls its helper then sets the root to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>there will be an empty tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a686803ea42d32427487652d229353846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::clearHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively deallocate all memory.</p>
<p>If the the tree is not empty, goes down all nodes on the left, checks if they have a right child. If they do recalls. If they dont, they get deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExprTree,the</td><td>tree to copy to and copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should two initialized trees </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>there will be two identical trees </dd></dl>
<p>if there is more to the left recall with child</p>
<p>if leftmost has a right child repeat process with the right child</p>
<p>deallocate </p>

</div>
</div>
<a class="anchor" id="aa38d3e51bdc88701cc2db1913c3b6065"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::copyHelp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>home</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively copy two trees to eachother.</p>
<p>Checks if the current Node from the tree to copy from is NULL. If it is, then will end. If the Node is not null will create a new node for the LHS tree with the same data then call itself for the left and right side of that node. Stopping condition is until they reach the end of RHS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Will</td><td>take in two BST Node pointers. One from each Tree. Should be corresponding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There should two initialized trees. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>There will be two identical trees. </dd></dl>
<p>Stopping condition, end of tree</p>
<p>Create node</p>
<p>Recall with the other parts of the tree </p>

</div>
</div>
<a class="anchor" id="aad81734b14dcf5a934965b54391e4f7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::countHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively count the number of items in the tree.</p>
<p>Basically adds one and recalls for the left and right every time a node is not NULL. If NULL then just adds 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BST</td><td>node, location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Int, the amount of nodes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>tree will be counted. </dd></dl>

</div>
</div>
<a class="anchor" id="a880d98553153533d3c29504e8a272c7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::getCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function counts the total amount of nodes in the BST.</p>
<p>calls the helper. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Int, the amount of nodes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>number of nodes will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a3850adc6b8ae965ec11ec0e0567b6f7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that will get the height of the tree.</p>
<p>Checks if the tree is empty. If it is, returns 0 for height. If it isnt, calls the helper. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Int, height of the tree.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the height will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fef36c2ff90833730980767afbe3735"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::heightHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively check for the height of the tree.</p>
<p>If reached the end returns 0, Otherwise keeps calling itself for the size of both the left and right part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BST</td><td>node. Current location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Int for the height.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>height will be returned </dd></dl>
<p>if we reached a null spot, return 0 since nothing is added</p>
<p>get the size of the left and right by recalling and going to the left and right</p>
<p>return which ever is larger plus one since the current node is part of the height </p>

</div>
</div>
<a class="anchor" id="ab86b4cea496ee53076021126423d51fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>newDataItem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that will insert a new item into the tree.</p>
<p>Inserts new data by calling its helper. Details will be there. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>new data. Could be of different types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>there will be another item in the tree with correct positioning. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f54ec6e60536aafa6e3130968e4858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::insertHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>newDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively find where to insert and insert the new data.</p>
<p>This first checks if we have gotten to a NULL pointer in the tree. If it has, then this is the location to insert the new node. If not, compare the data to the current location. If the data is bigger, then recall going right if less then recall going left until the correct positioning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Node</td><td>pointer and the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>there will be a new item. </dd></dl>
<p>if reached location, create the new node</p>
<p>if the current location is larger than data go left</p>
<p>if the current location is smaller than data, go right </p>

</div>
</div>
<a class="anchor" id="a43768375369ca8fe641a86451997ad45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that checks if the tree is empty.</p>
<p>Checks if the root is null to see if the tree is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if empty. False if not.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Nothing changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac36b0b564aa3c411c239d730f506f448"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp; <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the overloaded assignment operator.</p>
<p>Will set the tree equal to the tree in the parameter. This is done by calling the copyHelp function (details there.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Another</td><td>BST to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The copied BST.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There should two initialized trees. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>There will be two identical trees. </dd></dl>

</div>
</div>
<a class="anchor" id="a755549f7b88d0178a96ca84afd5e04cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>deleteKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that will look for something and delete it.</p>
<p>Calls its helper. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>thing to delete (keytype) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if found and deleted. False if not found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>there will one less node if asked to remove something found. </dd></dl>

</div>
</div>
<a class="anchor" id="a11efb310116399fde0c83c6991a37f7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::removeHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>deleteKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively find then delete a node. Then adjusts the tree.</p>
<p>If it has gotten to the end and it has still not found the keytype it ends. Once found checks how many children the node of the item has. If none, just deletes. If it has one then just points the current to the next of next. If two children, find the predeccsor and then overwrites the current data with the predeccesor then calls the removeHelp to delete the original predeccesor Node. If nothing is found but not null recalls with the appropriate side of the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BST</td><td>node, the current location. What to delete, keytype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if something is deleted. false if not found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>something will be deleted and tree will still be in order. </dd></dl>
<p>if at the end and not found, return false</p>
<p>if found, delete</p>
<p>if no children</p>
<p>if one child left child, no right</p>
<p>no left, right child</p>
<p>if two children</p>
<p>get predecessor</p>
<p>overwrite the value to delete with the predecessor</p>
<p>delete the node with the value just written to the new location</p>
<p>keep searching </p>

</div>
</div>
<a class="anchor" id="a4359bfee390669b5adaf0380ef62b18d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::retrieve </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>searchDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that checks to see if a piece of data is in the BST.</p>
<p>Calls the retrieve helper. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>thing to look for (KeyType) and where to put it (DataType) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bool, true if found. False if not.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Nothing changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aae2944702e1c5fe498b8fd93a2c28dab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::retrieveHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>searchDataItem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively check for a data item.</p>
<p>Checks if we have gotten to the end. If we have and still not found will return false. If the item in the current location is the same will set it equal to the parameter to copy to. If niether of those are true then checks to see if we are searching for something bigger or smaller than the current and go the corresponding way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BST</td><td>node pointer (where to check), the thing to look for (keytype), where to store if found (datatype) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if found, false if not.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Nothing changes. </dd></dl>
<p>if checked the complete tree, return false</p>
<p>if found, return true</p>
<p>if what were are looking for is smaller go left else go right </p>

</div>
</div>
<a class="anchor" id="a44b3002e3476eb410468a4b9aaaa73ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::showHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac28277cacbf8ab33326473a419abf097"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::showStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f08f48e6d1bbe3eb726856a947325e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::writeKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that will write the data in the tree in order.</p>
<p>Calls its helper. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>data will be printed on the screen. </dd></dl>

</div>
</div>
<a class="anchor" id="a36adcef767ab5a35a9de275aef841d9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::writeKeysHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a> *&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function that will recursively print out all the data in order.</p>
<p>Navigates all the way to the left of the BST, then prints out. Recalls the function with the children to the left of the most left node that has not been printed yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BST</td><td>node. The current location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>there should an initialized tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>data will be printed on the screen. </dd></dl>
<p>go all the way to the left</p>
<p>once all the way to the left print out the current</p>
<p>check for the children to the right of the most left node </p>

</div>
</div>
<a class="anchor" id="a92079e5301185f41eebe1c32c2357258"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , class KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::writeLessThan </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>searchKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOT USED </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a83534afce9094181ac031f9f596a8625"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType, class KeyType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_tree_1_1_b_s_tree_node.html">BSTreeNode</a>* <a class="el" href="class_b_s_tree.html">BSTree</a>&lt; DataType, KeyType &gt;::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_b_s_tree_8h_source.html">BSTree.h</a></li>
<li><a class="el" href="_b_s_tree_8cpp.html">BSTree.cpp</a></li>
<li><a class="el" href="show9_8cpp.html">show9.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 28 2014 22:36:28 for Hash by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
